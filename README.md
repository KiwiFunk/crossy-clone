# crossy-clone
A clone of Crossy Road

## Asset Creation
Three.js uses unitless measurements, so it's up to you to define what each unit represents in your project (in this case, 1 unit = 1 meter). 
When importing models, be careful - Three.js does not interpret real-world units like meters or centimeters. It only reads raw numerical values. 
For example, if your game treats 1 unit as 1 meter and you import a model designed in centimeters, a 100â€¯cm mesh would be interpreted as 100 units in Three.js if it wasnt normalized during the export process, which would incorrectly scale it to 100 meters in this project.

If there are any issues with scaling, its always worth using a site like https://3dviewer.net/ to check the actual size of the GLTF. For this project, a cube taking up a tile would be 1.0 x 1.0 x 1.0. Some exporters will normalize cm to m, but if all else fails, set the scene units to meters. 
For this project I have used Blender 4.4 with the Khronos glTF Blender I/O v4.4.55 extension. This has correctly scaled down my model by a factor of 100.

## Handling Spawning of Modular Assets
Some assets, such as logs, are made up of modular components. THis allows the logic to randomly chose a length and give a more procedural feel to world generation - as well as preventing the need to load/create multiple different models. The initial problem with this that needed solving was how do we make sure that each segment fits nicely together with no seams? This was done by creating a bbox around each mesh to calculate the size, and then use this to work out the size while creating the asset group. This worked - until the next problem came up. The terrain system needed to know the exact length of each asset group in order to prevent them overlapping. This information wasn't known until the end of the async function once each part had been loaded and checked. To solve this, I looked at how a lot of engines handle this - by precomputing bounding boxes or spheeres during import, and then storing this in metadata. This way all the information would be avaliable at runtime, without the need to measure on the fly - also giving us a small performance boost! As JavaScript is interpreted, this information would need hardcoding somewhere. For this I moved the original bbox calculation into its own function that can print mesh sizes into the console. These values can then be added into the config file whenever a new asset is added.